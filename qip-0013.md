<pre>
  QIP: 13
  Title: Poseidon2 Proof of Work  
  Author: Chris Smith <chris@quantus.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/Quantus-Network/improvement-proposals/discussions/
  Status: Draft
  Type: Standards
  Created: 2025-10-25
</pre>

## Abstract

This document describes a proof of work algorithm that mimics the desirable properties of Bitcoin's consensus algorithm, while offering a significant advantage to anyone wishing to prove block correctness in a ZK setting.

## Motivation

Cryptographic hash functions are weakened, but not destroyed by quantum computers. In fact, such hash functions are used as core primitives in the design of post-quantum-cryptographic algorithms, such as [SPHINCS+](https://sphincs.org/).

Using Grover's algorithm to reverse such hash functions is very impractical, [as it requires hundreds of thousands of gates and thousands of logical qubits](https://arxiv.org/abs/1603.09383) and only provides a quadratic speedup over classical methods. Therefore, we do not expect Grover's algorithm to be used to mine Bitcoin anytime soon.

However, SHA256 is notoriously inefficient when using a proving system like Plonk or STARKs. Therefore we use a newer hash function [Poseidon2](https://eprint.iacr.org/2023/323.pdf) which is optimized for ZK and therefore gives us a huge reduction in the number of gates and a corresponding speedup in proving time.

With this construction, miners can grind on nonces to find a "small enough" digest, where "small enough" is a dynamic difficulty threshold that updates via EMA every block, targeting a specific block time (starting at 12 seconds).

Overall this construction is meant to closely imitate Bitcoin's consensus algorithm with the only changes being the hash function and the frequency of difficulty updates.

## Specification

We expose a function "is_valid_nonce" that checks a block_hash and nonce against a given difficulty. For poseidon2, we choose a width of 12 and rate of 4 to give ~256 bits of classical preimage security. We squeeze out 512 bits from the poseidon sponge, hence the U512 usage.

```
pub fn is_valid_nonce(block_hash: [u8; 32], nonce: [u8; 64], difficulty: U512) -> (bool, U512) {
	if difficulty == U512::zero() {
		log::error!(
			"is_valid_nonce should not be called with 0 difficulty, but was for block_hash: {:?}",
			block_hash
		);
		return (false, U512::zero());
	}

	let hash_result = get_nonce_hash(block_hash, nonce);
	log::debug!(target: "math", "hash_result = {:x}, difficulty = {:x}",
		hash_result.low_u32() as u16, difficulty.low_u32() as u16);

	// In Bitcoin-style PoW, we check if hash < target
	// Where target = max_target / difficulty
	let max_target = U512::MAX;
	// Unchecked division because we catch difficulty == 0 above
	let target = max_target / difficulty;

	(hash_result < target, hash_result)
}

// Bitcoin-style double hashing with Poseidon2
pub fn get_nonce_hash(
	block_hash: [u8; 32], // 256-bit block_hash
	nonce: [u8; 64],      // 512-bit nonce
) -> U512 {
	// Concatenate block hash + nonce (like Bitcoin does with header + nonce)
	let mut input = [0u8; 96]; // 32 + 64 bytes
	input[..32].copy_from_slice(&block_hash);
	input[32..96].copy_from_slice(&nonce);

	// Double hash with Poseidon2 (like Bitcoin's double SHA256)
	let first_hash = qp_poseidon_core::hash_squeeze_twice(&input);
	let second_hash = qp_poseidon_core::hash_squeeze_twice(&first_hash);

	// Convert to U512 for difficulty comparison
	let result = U512::from_big_endian(&second_hash);

	log::debug!(target: "math", "hash = {:x} block_hash = {}, nonce = {:?}",
		result.low_u32() as u16, hex::encode(block_hash), nonce);

	result
}

/// Hash with 512-bit output by squeezing the sponge twice
pub fn hash_squeeze_twice(x: &[u8]) -> [u8; 64] {
	let mut st = Poseidon2State::new();
	st.append_bytes(x);
	st.finalize_twice()
}

```

## Reference Implementation

We implement this feature [here](https://github.com/Quantus-Network/backbone/tree/main/pallets/qpow).

Poseidon2 comes from Plonky3 [here](https://github.com/Quantus-Network/qp-poseidon). 

## Rationale

Poseidon2 offers up to a 70% reduction in gates compared to Poseidon1, which itself offers a 95% gate reduction compared to SHA256. 

The infrequent difficulty updates for Bitcoin (~every 2015 blocks) results in a chunkier difficulty function. By switching to exponential-moving-average (EMA), we can smooth out the difficulty function and respond to rapid changes in mining power.

## Copyright

This specification is released into the public domain.
