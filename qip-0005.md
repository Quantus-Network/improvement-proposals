<pre>
  QIP: 5
  Title: Validator Wormhole: A Privacy Technique For Blockchains
  Author: Chris Smith <chris@quantus.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/Quantus-Network/improvement-proposals/discussions/
  Status: Draft
  Type: Standards
  Created: 2025-01-14
</pre>

## Abstract

This document describes a privacy-preserving system that combines validator rewards with a token wormhole mechanism, similar to [EIP-7503](https://eips.ethereum.org/EIPS/eip-7503). This system allows users to privately send tokens while normalizing wormhole usage by requiring validators to use it to claim their rewards.

One may think of a wormhole as clipping an edge in the transaction graph.

## Motivation

Blockchain transactions are inherently public, creating privacy concerns for users who wish to transact without revealing their financial history. While various privacy solutions exist, they often suffer from limited adoption and therefore provide insufficient anonymity sets. By integrating privacy mechanisms with validator rewards, this proposal creates a natural incentive for privacy tool usage while providing validators with privacy by default.

## Specification

<img src=qip-0005/circuit.jpg></img>

### 1. Wormhole

Users send tokens to what appears to be a normal account but is provably unspendable. The account is unspendable because, instead of being a hash of a public key, it is the double hash of a salt + secret. The salt + double hashing protects the wormhole from false-positives, where the zk-proof is convinced that the account is unspendable but is in fact the single-hash of a public key and therefore spendable. In particular, in lattice cryptography, the public keys are much larger than the 32 or 64 byte hash digests, so the security of the construction reduces to finding a second preimage of the public key.

The entrance is "covered" - indistinguishable from normal accounts. This is because it is a cryptographic hash, just like [normal Substrate accounts](https://github.com/paritytech/polkadot-sdk/blob/master/substrate/primitives/core/src/crypto.rs#L516).

Users retain proof of unspendability (secret pre-image) for later claims.

A nullifier is used to prevent double-claims of the same burned tokens. The zk-circuit verifies that the nullifier was correctly computed: `nullifier = H(H(salt + secret + global_transfer_count))`.

Unspendable addresses can be re-used because the nullifier will be different for different extrinsic indices, and the secret will be retained.

The secret must be retained by the wallet and should therefore be derived deterministically from the wallet seed, just as private/public keys.

### 2. Validator Rewards

Blockchain validators (or miners) receive rewards in exchange for their services. These rewards are not directly given to them, but sent through a wormhole for them to collect on the exit.

This gives validators privacy by default as well as cover for users exiting through wormholes. Transaction fees are sent in a separate transaction to decrease the possibility of correlation attacks.

To enforce this behavior, the protocol can require validators to publish a single hash `H(salt + secret)`. This is not the double hash, so it does not enable anyone to spend these coins, but it does prove that the validator in fact used the wormhole.

### 3. Zero-Knowledge Proof System

A zero-knowledge-proof (ZKP) proves that a wormhole was entered, and with what amount. This proof is generated by the user's wallet before entering the wormhole and is presented to the protocol in order to "re-mint" coins. The public inputs are submitted on chain, along with the proof itself. The private inputs are kept on the wallet and not revealed on chain.

We chose [plonky2](../qip-0005/QIP-0005-2.pdf) because it has
- it uses FRI (from STARKs), which is post-quantum
- no trusted setup
- very efficient proving and verification
- easy proof aggregation
- rust-native
- reasonably easy to [get verifier working](https://github.com/Quantus-Network/plonky2) into no-std state for Substrate

#### Public Inputs For Wormhole Proof

```rust
struct WormholeProofPublicInputs {
    // Prevents double-claims (double hash of salt + txid + secret)
    nullifier: [u8; 64],
    // Account the user wishes to withdraw to
    exit_account: AccountId,
    // Amount to be given to exit_account
    exit_amount: u128,
    // Used to verify the transaction success event
    storage_root: [u8; 32],
}
```

#### Private Inputs For Wormhole Proof

```rust
struct WormholeProofPrivateInputs {
    // Event that resulted from funding the unspendable address
    // TODO: fix this
    funding_event: Vec<u8>,
    // Unspendable account
    unspendable_account: AccountId,
    // Proves balance
    storage_proof: Vec<u8>,
    // Secret value preimage of unspendable_address
    // this is also used in the nullifier computation
    unspendable_secret: Vec<u8>,
}
```

### 4. Verification Circuit

The zk-circuit verifies:

1. **Unspendable account is actually unspendable**: `AccountId = H(H(salt+secret))`
2. **The nullifier was computed correctly**: `H(H('nullifier'+extrinsic_index+secret))`
3. **A storage proof that the funding transaction resulted in a success event**: Storage proof is a merkle-patricia-proof connecting the transfer success event to the storage-root.

#### Implementation Notes For Substrate:

- Events are stored in the storage trie.
- Recent block headers and their storage roots are stored in current state and can be referenced by block number, which should be sent along with the storage-root for O(1) lookup.
- Any recent block's storage-root can be used for the storage proof. If a block moves out of the recent-set before the wormhole exit is included in a block, the wallet can recreate the storage-proof from a more recent block and resubmit it.
- The `fee_amount + exit_amount = funding_tx_amount`.

### 5. Consensus

Network observers (other validators and lite-clients) can check that the public inputs to the entrance proof are valid:
- Storage root is current enough
- Nullifier has never been used before

### 6. Privacy Properties

- **Entrance is indistinguishable from normal transfers**
- **Exit is indistinguishable from mining rewards up to amounts**
- Wormhole accounts can be sent to others for use without them knowing it is a wormhole address
- Exit accounts can also be wormhole accounts, so wormholes can be chained together
- Wormhole transactions can actually be sent to the same wormhole entrance address, confusing the apparent current balance of the unspendable address

### 7. Security Notes

- Faulty wormhole proof implementation could create an inflation bug
- Users could prove an address is a wormhole address by publishing `H(salt + secret)`
- Validator-rewards can be distributed among delegators in a pool or any other accounting scheme to provide a parallel explanation for coins going to multiple addresses
- Wormhole amounts should have one significant digit (or even better, one significant bit) to increase anonymity set and reduce potential for correlation attacks
- Validators can choose amounts distributed to beneficiaries to match amounts in unused addresses, increasing anonymity set for given amounts
- Wormhole exit transactions will be unsigned, and should be sent to the blockchain via some anonymous channel (Unsigned-extrinsics in substrate)

### 8. Economic Notes

- The total supply of coins must be calculated via validator rewards, as wormhole exits appear to create new coins. We do this in Substrate by using the functions [`increase_balance` and `withdraw`](https://github.com/Quantus-Network/chain/blob/main/pallets/wormhole/src/lib.rs) to re-mint the coins and deduct fees.
- An inflation bug due to a faulty implementation would be economically-detectable only if the amount of reminted coins exceeded the sum of the balances of addresses that have 0 sends from them.

## Reference Implementation

We implement the circuit [here](https://github.com/Quantus-Network/zk-circuits), and connect the verifier to the chain [here](https://github.com/Quantus-Network/chain/blob/main/pallets/wormhole/src/lib.rs).

## Rationale

I did the math, if we only check the last 3 field elements (felts) for equality it works out that...
the trie should not be so large that the leaf partial key has less than 3 felts until we have 2^32 ~= 4.3B
an attacker trying to falsify the proof has to find a collision on 2^192 preimages, so ~96 bits of security

This also means we don't have to split felts in the circuit, we can just take the last 3 after poseidon gives us 4.
If we do approach that many wormhole txs, then we can reconfigure poseidon to output 8 felts for the leaf hash

### Design Decisions

**Double Hashing for Unspendable Addresses**: The use of double hashing (`H(H(salt+secret))`) instead of single hashing prevents false positives where an attacker might find a public key that hashes to the same value as the wormhole address.

**Validator Integration**: By requiring validators to use the wormhole system for reward collection, we ensure a baseline level of usage that provides cover traffic for privacy-seeking users. This solves the adoption problem that plagues many privacy solutions.

**Nullifier Design**: The nullifier construction using `H(H(salt + secret + global_transfer_counter))` prevents double-spending while allowing address reuse across different transactions.

**Storage Proof Verification**: Using merkle-patricia proofs against recent storage roots allows efficient verification of funding transactions without requiring the full blockchain state in the circuit.



## Copyright

This specification is released into the public domain.
