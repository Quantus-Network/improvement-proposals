<pre>
  RIP: 2
  Title: Hierarchical Deterministic Wallets For Lattice Keys
  Author: Chris Smith <chris@resonancenetwork.io>
  Comments-Summary: No comments yet.
  Comments-URI: https://gitlab.com/resonance-network/improvement-proposals/-/wikis/Comments:RIP-0002
  Status: Draft
  Type: Standards
  Created: 2025-01-27
</pre>

## Abstract

This document describes a hierarchical deterministic wallet scheme that works with lattice-cryptography.

## Motivation

Hierarchical Deterministic Wallets [HD-Wallets](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki) have 
become the de-facto standard in blockchain. As the blockchain industry discussed a post-quantum future, we would like to
apply this technique to keys in a lattice cryptography setting, as the user experience of backing up a single seed 
phrase that generates unlimited a-priori-unconnected keys is highly preferable to users having to back-up the same 
wallet each time a certain action is performed. We focus on the Falcon and Dilithium signature schemes as these are the 
NIST finalists and likely to become industry standards.

The challenge with adapting lattice cryptography to an HD setting is two-fold. First is that the output of an HMAC-SHA512 
cannot be used as-is for a lattice private key. For 
[Falcon and Dilithium](https://csrc.nist.gov/Projects/post-quantum-cryptography/selected-algorithms-2022) 
we need polynomials that form a "good basis" (small vectors) for the lattice, and the key generation algorithms use rejection
sampling, which does not fit into the HD wallet scheme without modification.

The second challenge is that, in BIP32, non-hardened keys are derived via addition of elliptic-curve points (public keys)
and the set of lattice public keys are not closed under addition or multiplication. 

We address the first challenge in this RIP. It is, to our knowledge, an open research question whether the second 
challenge can be overcome in the lattice cryptography setting. Non-hardened keys are used for watch-only or audit 
wallets and are not essential to the primary use of HD-Wallets.

## Specification

The essential idea is to use the entropy output from HMAC at each iteration as the RNG for polynomial sampling. In BIP32,
half of the output of the HMAC is used as the private key, either directly as in the "hardened" case, or added to the 
previous private key, in the "non-hardened" case. This works because of the structure of elliptic curve cryptographic
algorithms, where the private key can be viewed as just an integer that is multiplied by the generator point in the 
elliptic curve group. 

In both Falcon and Dilithium, the key generation algorithms consume <= 64 bytes of entropy in the key derivation process.
We simply feed the entire output of the HMAC into the key generation process, instead of using half as the private key
itself. Otherwise, the scheme is identical to hardened key derivation in BIP32. See this diagram for a summary of changes.

<img src=rip-0002/derivation.png></img>

<img src=rip-0002/HD-Lattice.jpg></img>


## Reference Implementation

We rely on Thomas Pornin's [rust-fn-dsa](https://github.com/Resonance-Network/rust-fn-dsa?tab=readme-ov-file) implementation
of the FALCON signature algorithm, with some minor modifications to allow for externally generated entropy. Thomas Pornin
was one of the authors on the FALCON standard, and also the author of the PQClean C-lang implementation of the algorithm.

Our wallet implementation lives [here](https://gitlab.com/resonance-network/rusty-falcon). It uses the rust library bip39
to get from a mnemonic "seed phrase" to a "seed". We then derive a "master key" from the seed via HMAC-SHA512 and that
forms the root of the tree of keys, with each edge representing HMAC-SHA512(R || 0x00 || L || child_index) where L || R
are the split values of the parent in the tree, as described in the BIP32 standard. 

## Rationale

Both Dilithium and Falcon require <= 64 bytes of entropy as input to the key generation process, so we can simply use the 
64 byte output of HMAC-SHA512 directly. The non-hardened use case is not obviously achievable with lattice cryptography,
which is why we omit it.

## Copyright

This specification is released into the public domain.

